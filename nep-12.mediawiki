<pre>
  NEP: 12
  Title: Unified dApp API for wallet providers
  Author: Nick Fujita <nickfujita@gmail.com>, Matus Zamborsky <zamborsky@gmail.com>
  Type: Standard
  Status: Accepted
  Created: 2018-08-28
</pre>

==Abstract==

This NEP describes a common API interface for dApps to communicate with external wallet providers. The use of a trusted 3rd party wallet providers will help users feel more secure when using dApps, and the unified interface will help dApp creators to have a more uniform developer experience when making their dApps compatible with various providers.


==Motivation==

===End Users===

As dApps come into the ecosystem, there will be more concerns about the safety of user assets. If dApps all required users to input their private keys in order to use them, it just takes one malicious dApp to steal all their funds. By using a trusted wallet provider which interfaces with the various dApps in the ecosystem on their behalf, users can reduce the exposure of their private keys. This will even allow users to transact with their hardware wallets via the wallet provider, never having to reveal their private keys even to the wallet itself.

===dApp Developers===

One of the initial hurdles for any developer when starting to develop a dApp is to create a wallet module that will allow the user and application to interface with the NEO blockchain. While there are many quality SDKs out there, such as neon-js, for facilitating the communication of these requests, there are often many hurdles to successfully construct the right combination of methods, along with input and output parsing. The issue only gets amplified when trying to integrate with hardware wallet providers such as a Ledger device.

While there may be several options for 3rd party wallet providers that will help them to facilitate these transactions, there is currently no common consensus on the consistency of their interfaces. With a lack of consistency in interfaces to use these wallet provider services, dApp developers will be forced to make a decision to have their platform supported by a single provider, or to double or even triple their development efforts to accommodate all the different wallet provider interfaces. This will lead to a fragmentation in the dApps ecosystem.

===Wallet providers===

Each wallet provider, when deciding on supporting dApps to utilize their services as an authentication mechanism will be faced with a decision on how to implement an API to communicate with the dApps. Wallet providers can choose to create their own API from scratch, create their own version of existing projects, or aim to directly duplicate an existing API. In the case that the provider decides to make their own API interface from scratch, and try to promote dApps to use it, time and effort will inevitably be wasted by both the provider and competing providers on getting dApp developers on board with using their custom communication interface. If we have a unified interface for such transactions, providers could spend more time on making their individual services better for their users.

The current list of wallet providers that can benefit from the use of this protocol are currently:
* NEL Chrome extension
* nOS dApps browser
* NeoLink Chrome extension
* NEX Chrome extension
* O3 dApps browser

Each wallet provider has its own value proposition to its users beyond the interface from this protocol itself, so it seems that formalizing it would be a net positive for all.

Additionally, since there is a significant amount of overlap in the protocols between NEO and Ontology for sending assets, and interacting with a contract on NeoVM, this proposal is a joint effort with [https://github.com/ontio/OEPs/pull/8 OEP6]. Since there are differences in the two platforms, the result of these proposals will not be identical, nor should they be, but getting as much overlap as possible will help to simplify cross-chain interactions for both platforms.


==Specification==

'''Provider Request Handling'''

Implementation details per dApp domain handling will be left to the discretion of the wallet provider. Providers can choose to allow users to trust certain dApps to automatically execute transactions on their behalf, or a certain subset of transaction types. Below are basic guidelines for the general handling of requests from dApps via the protocol interface.

''Wallet Provider dAPI Client Integration Package Versioning```

Providers of client packages for dApps shall provide versioned integration packages which facilitate the communication of these messages back to supported wallet providers. It is crucial that these packages be versioned in order to protect the dApps from potential future updates to the interface. In this way, a dApp should be able to use a fixed version of the dAPI method interfaces as long as it's supported by the wallet provider. Wallet providers should look to provide support for legacy versions of client packages provided starting from the time the spec for this NEP has been finalized and merged.

===Read Methods===

====getProvider====
Returns information about the dAPI provider, including who this provider is, the version of their dAPI, and the NEP that the interface is compatible with.


'''Method Interface'''

<pre>
function getProvider(): Promise<Provider>
</pre>


'''Input arguments'''

None


'''Success return value'''

object - Provider information defined by the interface below:
<pre>
interface Provider {
  name: string;
  website: string;
  version: string;
  compatibility: string[];
  extra: object; //this object can contain any attributes specific to the dapi provider, such as an app theme.
}
</pre>

The compatibility field will return a list of strings that corresponds to NEPs that the dAPI conforms to. For example:
<pre>
compatibility: [
    'NEP-14',
    'NEP-23',
    'NEP-29'
]
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_DENIED`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getProvider()
.then((provider: Provider) => {
  const {
    name,
    website,
    version,
    compatibility,
    extra,
  } = provider;

  console.log('Provider name: ' + name);
  console.log('Provider website: ' + website);
  console.log('Provider dAPI version: ' + version);
  console.log('Provider dAPI compatibility: ' + JSON.stringify(compatibility));
  console.log('Extra provider specific atributes: ' + JSON.stringify(compatibility));
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_DENIED:
      console.log('The user rejected the request to connect with your dApp.');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request, return:
* The name of the provider wallet
* The provider website
* The provider specific version of the wallet
* A list of NEP for which the specific provider protocol is compatible with

Example
<pre>
{
  name: 'Awesome Wallet',
  website: 'https://www.awesome.com',
  version: 'v0.0.1',
  compatibility: [
    'NEP-14',
    'NEP-23',
    'NEP-29'
  ],
  extra: {
    theme: 'Dark Mode'
  }
}
</pre>


====getNetworks====
Returns the networks the wallet provider has available to connect to, along with the default network the wallet is currently set to.


'''Method Interface'''

<pre>
function getNetworks(): Promise<Networks>
</pre>


'''Input arguments'''

None


'''Success return value'''

<pre>
interface Networks {
  networks: string[]; // Array of network names the wallet provider has available for the dapp developer to connect to.
  defaultNetwork: string; // Network the wallet is currently set to.
}
</pre>

'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_DENIED`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getNetworks()
.then(response => {
  const {
    networks,
    defaultNetwork,
  } = response.networks;

  console.log('Networks: ' + networks);
  // eg. ["MainNet", "TestNet", "PrivateNet"]

  console.log('Default network: ' + defaultNetwork);
  // eg. "MainNet"
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_DENIED:
      console.log('The user rejected the request to connect with your dApp');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request, return:
- The list of NEO networks that the wallet is able to connect to. The return values will be used by the dApp developer to communicate to which network they would like their request to be directed to. The wallet provider will be responsible for the logistics of which node to submit any request to for each network alias provided.
- The wallet provider is to also return the default network that the wallet UI is currently set to by the user.

Example
<pre>
{
  networks: ["MainNet", "TestNet", "PrivateNet"],
  defaultNetwork: "TestNet",
}
</pre>


====getAccount====
Return the Account that is currently connected to the dApp.


'''Method Interface'''

<pre>
function getAccount(): Promise<{ address: string, label: string }>
</pre>


'''Input arguments'''

None


'''Success return value'''

<pre>
interface Account {
  address: string; // Address of the connected account, Base58 string format
  label?: string; // A label the users has set to identify their wallet
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_DENIED`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getAccount()
.then((account: Account) => {
  const {
    address,
    label
  } = account;

  console.log('Provider address: ' + address);
  console.log('Provider account label (Optional): ' + label);
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_DENIED:
      console.log('The user rejected the request to connect with your dApp');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request, return:
- The address and label of the account currently selected by the user in the wallet interface

Example
<pre>
{
  address: 'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru',
  label: 'My Spending Wallet'
}
</pre>


====getPublicKey====
Return the public key, in hexstring format, of the Account that is currently connected to the dApp.


'''Method Interface'''

<pre>
function getPublicKey(): Promise<{ address: string, publicKey: string }>
</pre>


'''Input arguments'''

None


'''Success return value'''

<pre>
interface Account {
  address: string; // Address of the connected account, Base58 string format
  publicKey: string; // Public key of the connected account, in hexstring format
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_DENIED`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getPublicKey()
.then((publicKeyData: PublicKeyData) => {
  const {
    address,
    publicKey,
  } = publicKeyData;

  console.log('Account address: ' + address);
  console.log('Account public key: ' + publicKey);
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_DENIED:
      console.log('The user rejected the request to connect with your dApp');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request, return:
- The address and public key of the account currently selected by the user in the wallet interface, in hexstring format

Example
<pre>
{
  address: 'ATUaTd3LA4kZiyB6it9fdb5oJpZYMBF4DX',
  publicKey: '03fa41b6ff75ebeff8464556629cfceae7402f5d815626a7a6542f786974b942e0'
}
</pre>


====getBalance====
Return balance of a specific asset for the given account.

If the asset is omitted from a request to MainNet, all asset and token balances will be returned.


'''Method Interface'''

<pre>
function getBalance(args: GetBalanceArgs): Promise<BalanceResults>
</pre>


'''Input arguments'''

<pre>
interface GetBalanceArgs {
  params: BalanceRequest|BalanceRequest[];
  network?: string - Network to submit this request to. If omitted, it will default to the network the wallet is currently set to.
}

interface BalanceRequest {
  address: string; // Address to check balance(s)
  assets?: string[]; // Asset IDs or script hashes to check balance.
  fetchUTXO?: boolean; // Fetches to UTXO data for NEO and/or GAS if attribute is 'true'
}
</pre>


'''Success return value'''

<pre>
interface BalanceResults {
  [address: string]: Balance[];
}

interface Balance {
  assetID: string;
  symbol: string;
  amount: string;
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_DENIED`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getBalance({
  params: {
    address: 'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru',
    assets: ['c36aee199dbba6c3f439983657558cfb67629599']
  },
})
.then((results: BalanceResults) => {
  Object.keys(results).forEach(address => {
    const balances = results[address];
    balances.forEach(balance => {
      const { assetID, symbol, amount } = balance

      console.log('Address: ' + address);
      console.log('Asset ID: ' + assetID);
      console.log('Asset symbol: ' + symbol);
      console.log('Amount: ' + amount);
    });
  });
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_DENIED:
      console.log('The user rejected the request to connect with your dApp');
      break;
  }
});
</pre>

Single asset balance request sample
<pre>
// input
{
  params: {
    address: 'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru',
    assets: ['c36aee199dbba6c3f439983657558cfb67629599']
  },
}

// output
{
  'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru': [
    {
      'assetID': 'c36aee199dbba6c3f439983657558cfb67629599',
      'symbol': 'NKN',
      'amount': '0.00000233',
    }
  ],
}
</pre>

Single account balances request sample
<pre>
// input
{
  params: {
    address: 'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru',
  },
}

// output
{
  'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru': [
    {
      'assetID': 'c56f33fc6ecfcd0c225c4ab356fee59390af8560be0e930faebe74a6daff7c9b',
      'symbol': 'NEO',
      'amount': '10',
    },
    {
      'assetID': '602c79718b16e442de58778e148d0b1084e3b2dffd5de6b7b16cee7969282de7',
      'symbol': 'GAS',
      'amount': '777.0001',
    },
    {
      'assetID': 'c36aee199dbba6c3f439983657558cfb67629599',
      'symbol': 'NKN',
      'amount': '0.00000233',
    },
    {
      'assetID': 'fc732edee1efdf968c23c20a9628eaa5a6ccb934',
      'symbol': 'NNC',
      'amount': '2000',
    }
  ]
}

Multiple account balances request sample
<pre>
// input
{
  params: [
    {
      address: 'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru',
    },
    {
      address: 'AbKNY45nRDy6B65YPVz1B6YXiTnzRqU2uQ',
      assets: ['1578103c13e39df15d0d29826d957e85d770d8c9'],
    },
  ]
}

// output
{
  'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru': [
    {
      'assetID': 'c56f33fc6ecfcd0c225c4ab356fee59390af8560be0e930faebe74a6daff7c9b',
      'symbol': 'NEO',
      'amount': '10',
    },
    {
      'assetID': '602c79718b16e442de58778e148d0b1084e3b2dffd5de6b7b16cee7969282de7',
      'symbol': 'GAS',
      'amount': '777.0001',
    },
    {
      'assetID': 'c36aee199dbba6c3f439983657558cfb67629599',
      'symbol': 'NKN',
      'amount': '0.00000233',
    },
    {
      'assetID': 'fc732edee1efdf968c23c20a9628eaa5a6ccb934',
      'symbol': 'NNC',
      'amount': '2000',
    }
  ],
  'AbKNY45nRDy6B65YPVz1B6YXiTnzRqU2uQ': [
    {
      'assetID': '1578103c13e39df15d0d29826d957e85d770d8c9',
      'symbol': 'PHX',
      'amount': '11000',
    }
  ]
}
</pre>

'''Provider Request Handling'''

Upon receiving this request, fetch the latest balance(s) for each given account, for the specific asset if applicable.
Typechecking will be required on the input argument, as it can be either a single BalanceRequest object or an array of BalanceRequest objects. In the case where a specific asset is not provided to check the balance for, the wallet provider will fetch balances for all assets and tokens for that account.


====getStorage====
Reads the raw value in smart contract storage.


'''Method Interface'''

<pre>
function getStorage({ scriptHash: string, key: string, network?: string }): Promise<StorageResponse>
</pre>


'''Input arguments'''

<pre>
interface GetStorageArgs {
  scriptHash: string; // script hash of the smart contract to invoke a read on, in hexstring format
  key: string; // key of the storage value to retrieve from the contract
  network?: string - Network to submit this request to. If omitted, it will default to the network the wallet is currently set to.
}
</pre>


'''Success return value'''

<pre>
interface StorageResponse {
  result: string; // The raw value that's stored in the contract
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_REFUSED`|`RPC_ERROR`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getStorage({
  scriptHash: '505663a29d83663a838eee091249abd167e928f5',
  key: 'game.status'
})
.then(res => {
  const value = res.result;
  console.log('Storage value: ' + value);
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_REFUSED:
      console.log('Connection dApp not connected. Please call the "connect" function.');
      break;
    case RPC_ERROR:
      console.log('There was an error when broadcasting this transaction to the network.');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Validate and format the inputs
** Script hash is valid
* Broadcast the RPC request
* Return the RPC response results

Example
<pre>
{
  result: '68656c6c6f20776f726c64'
}
</pre>


====invokeRead====
Execute a contract invocation in read-only mode.


'''Method Interface'''

<pre>
function invokeRead({
  scriptHash: string,
  operation: string,
  args: Argument[]
  network?: string,
 }): Promise<result: Object>
</pre>

'''Input arguments'''

<pre>
interface InvokeReadArgs {
  scriptHash: string; // script hash of the smart contract to invoke a read on
  operation: string; // operation on the smart contract to call
  args: Argument[]; // any input arguments for the operation
  network?: string - Network to submit this request to. If omitted, it will default to the network the wallet is currently set to.
}

interface Argument {
  type: ArgumentDataType;
  value: any;
}

type ArgumentDataType = 'String'|'Boolean'|'Hash160'|'Hash256'|'Integer'|'ByteArray'|'Array'|'Address';
</pre>


'''Success return value'''

result: Object - Response from RPC node


'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_REFUSED`|`RPC_ERROR`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
invokeRead({
  scriptHash: '505663a29d83663a838eee091249abd167e928f5',
  operation: 'calculatorAdd',
  arguments: [
    {
      type: 'integer',
      value: 2
    },
    {
      type: 'integer',
      value: 10
    }
  ]
})
.then((result: Object) => {
  console.log('Read invocation result: ' + JSON.stringigy(result));
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_REFUSED:
      console.log('Connection dApp not connected. Please call the "connect" function.');
      break;
   case RPC_ERROR:
    console.log('There was an error when broadcasting this transaction to the network.');
    break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Validate and format the inputs
** Script hash is valid
** Format parameters
*** If `byteArray`, convert to appropriate hexstring based on assumed format
* Broadcast the RPC request
* Return the RPC response results

Example
<pre>
{
  script: '8h89fh398f42f.....89hf2894hf9834',
  state: 'HALT, BREAK',
  gas_consumed: '0.13',
  stack: [
    {
      type: 'Integer',
      value: '1337'
    }
  ]
}
</pre>


====getBlock====
Get information about a specific block.


'''Method Interface'''

<pre>
function getBlock({
  blockHeight: integer,
  network?: string
}): Promise<{result: BlockDetails}>
</pre>


'''Input arguments'''

<pre>
interface GetBlockInputArgs {
  blockHeight: integer;
  network?: string;
}
</pre>


'''Success return value'''

<pre>
interface BlockDetails {
  hash: string; // Block hash
  size: number; // Block size (bytes)
  version: number; // The version number of the block execution
  previousblockhash: string; // Previous block Hash
  merkleroot: string; // Merkel root
  time: number; // Block generation timestamp
  index: number; // Block index (height)
  nonce: string; // Block pseudo-random number
  nextconsensus: string; // Next master biller
  script: ScriptDetails; // Block call signature authentication information
  tx: BlockTransactionDetails[]; // Block containing trading group
  confirmations: number; // Confirmation number (number of blocks after this block)
  nextblockhash: string; // Next block hash
}

interface BlockTransactionDetails {
  txid: string;
  size: number;
  type: string;
  version: number;
  attributes: any[];
  vin: any[];
  vout: any[];
  sys_fee: string;
  net_fee: string;
  scripts: any[];
  nonce: number;
}

interface ScriptDetails {
  invocation: string;
  verification: string;
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string;
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getBlock({
  blockHeight: 2619690,
  network: 'TestNet'
})
.then((result: Object) => {
  console.log('Block information: ' + JSON.stringigy(result));
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
   case RPC_ERROR:
    console.log('There was an error when broadcasting this transaction to the network.');
    break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Broadcast the RPC request
* Return the RPC response results


Example
<pre>
{
  "hash": "0xc1668a114ee680597196ed402a0e0507fd8348e6090a54250d7accfadbd74b6e",
  "size": 686,
  "version": 0,
  "previousblockhash": "0xbae289c94e17ae90022673186fd6e1e48b7dd7afb89319bff0e2832db06d16b3",
  "merkleroot": "0x07d70f7337d3869a7daa538425d78a47212fb8c6130d66d84ac48526853a4e51",
  "time": 1557376153,
  "index": 2619690,
  "nonce": "8efd62ebb85ee68b",
  "nextconsensus": "AWZo4qAxhT8fwKL93QATSjCYCgHmCY1XLB",
  "script": {
    "invocation": "402a1dab9e5593d1d7d2a22a36772d4541b8053d33f8b8474b7d5a20066c1bd821e051fc252ed16146930d55ecb17fbb74972fba4c4b27af81a707999ca1313dd2401520eba2dd3b54a74a798cbb716c484ba6f6f21218f099e3d622a0fbd15989f38f9b0b344daf9b89175055d3a92f49df65118e8598735d651bedd4f1811baeb140e6491c03f3057f404d2fe7db50e40e82ade405a9dc7fccd81f4ba0b499a4a29f8570d631b8d40c5995b17d9391fe9ff8c73f28a4e1eb922b7a1ce9d1a5dc0448402cfcdede54828875d45402120aa2d8f78c7bd40df5e5d3b1873fd7e4d03672ebd0904f90c90fa519c623968f55550ae55374de66dc0db9c9d865c593bb95be5640214db0cd3cea6f4ad866df4129d482b89583805d1bdb08ce8399881e70351778a3e4a4093cf69aa7b99b83347fbfd38d85ff45d6a78ca2ab8cacffbfbc8c2d16",
    "verification": "5521030ef96257401b803da5dd201233e2be828795672b775dd674d69df83f7aec1e36210327da12b5c40200e9f65569476bbff2218da4f32548ff43b6387ec1416a231ee821025bdf3f181f53e9696227843950deb72dcd374ded17c057159513c3d0abe20b64210266b588e350ab63b850e55dbfed0feeda44410a30966341b371014b803a15af0721026ce35b29147ad09e4afe4ec4a7319095f08198fa8babbe3c56e970b143528d222103c089d7122b840a4935234e82e26ae5efd0c2acb627239dc9f207311337b6f2c12103fd95a9cb3098e6447d0de9f76cc97fd5e36830f9c7044457c15a0e81316bf28f57ae"
  },
  "tx": [
    {
      "txid": "0x07d70f7337d3869a7daa538425d78a47212fb8c6130d66d84ac48526853a4e51",
      "size": 10,
      "type": "MinerTransaction",
      "version": 0,
      "attributes": [],
      "vin": [],
      "vout": [],
      "sys_fee": "0",
      "net_fee": "0",
      "scripts": [],
      "nonce": 3093227147
    }
  ],
  "confirmations": 70,
  "nextblockhash": "0x2c9d6a107b21e83e09dd1b89df344a726895147d410120c46996290692ba29aa"
}
</pre>


====getBlockHeight====
Get the height of the current block.


'''Method Interface'''

<pre>
function getBlockHeight({
  network?: string
}): Promise<{result: BlockHeight}>
</pre>


'''Input arguments'''

<pre>
interface GetBlockHeightInputArgs {
  network?: string;
}
</pre>


'''Success return value'''

<pre>
interface BlockHeight {
  result: number // Block height
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string;
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getBlockHeight({
  network: 'TestNet'
})
.then((res: {result: number}) => {
  console.log('Block height: ' + res.result);
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
   case RPC_ERROR:
    console.log('There was an error when broadcasting this transaction to the network.');
    break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Broadcast the RPC request
* Return the RPC response results


Example
<pre>
{
  "result": 2619690
}
</pre>


====getTransaction====
Get information about a specific transaction.


'''Method Interface'''

<pre>
function getTransaction({
  txid: string,
  network?: string
}): Promise<{result: TransactionDetails}>
</pre>


'''Input arguments'''

<pre>
interface TransactionInputArgs {
  txid: string;
  network?: string;
}
</pre>


'''Success return value'''

<pre>
export interface TransactionDetails {
  txid: string;
  size: number;
  type: string;
  version: number;
  attributes: TransactionAttribute[];
  vin: any[];
  vout: any[];
  sys_fee: string;
  net_fee: string;
  scripts: TransactionScript[];
  script: string;
  gas: string;
  blockhash: string;
  confirmations: number;
  blocktime: number;
}

interface TransactionAttribute {
  usage: string;
  data: string;
}

interface TransactionScript {
  invocation: string;
  verification: string;
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string;
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getTransaction({
  txid: '7e049fd7c253dabf38e4156df30c78b30d49f307196aa89b99a47d2330789bf2',
  network: 'TestNet'
})
.then((result: Object) => {
  console.log('Transaction details: ' + JSON.stringify(result));
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
   case RPC_ERROR:
    console.log('There was an error when broadcasting this transaction to the network.');
    break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Broadcast the RPC request
* Return the RPC response results


Example
<pre>
{
  "txid": "0x7e049fd7c253dabf38e4156df30c78b30d49f307196aa89b99a47d2330789bf2",
  "size": 556,
  "type": "InvocationTransaction",
  "version": 1,
  "attributes": [
    {
      "usage": "Script",
      "data": "296ac124021a71c449a9bad320c16429b08ad6ee"
    },
    {
      "usage": "Remark",
      "data": "cbb549adec34d741"
    }
  ],
  "vin": [],
  "vout": [],
  "sys_fee": "0",
  "net_fee": "0",
  "scripts": [
    {
      "invocation": "4072b83e8aca62c27dc36b032b895e757db00620384e26f43cd0ecc9904bff1e652dd94a03226d6dcb0b6f91104cb40be6455aa0fc3b474a8a8e5fa43ff4b10b8d40af726dc0976f15cd8a134634074c5613ab1e59979fec37b611392975c92afa11038fd9d96ddfb306df12ae200dc3c15fa17cb9530389e28f090fd8c9721c3307",
      "verification": "53c56b6c766b00527ac46c766b51527ac4616c766b00c36121022949376faacb0c6783da8ab63548926cb3a2e8d786063a449833f927fa8853f0ac642f006c766b51c361210292a25f5f0772d73d3fb50d42bb3cb443505b15e106789d19efa4d09c5ddca756ac635f006c766b00c361210292a25f5f0772d73d3fb50d42bb3cb443505b15e106789d19efa4d09c5ddca756ac642f006c766b51c36121022949376faacb0c6783da8ab63548926cb3a2e8d786063a449833f927fa8853f0ac62040000620400516c766b52527ac46203006c766b52c3616c7566"
    }
  ],
  "script": "0400e1f505147869ef9732cdf6f6d54adaa5cae3b55a9396bceb14296ac124021a71c449a9bad320c16429b08ad6ee53c1087472616e7366657267f1dfcf0051ec48ec95c8d0569e0b95075d099d84f10400e1f50514b1fdddf658ce5ff9f83e66ede2f333ecfcc0463e14296ac124021a71c449a9bad320c16429b08ad6ee53c1087472616e7366657267f1dfcf0051ec48ec95c8d0569e0b95075d099d84f1",
  "gas": "0",
  "blockhash": "0x4ea57fe267a392933d2b03fa733fbf1fa12c13f7e8ae2051e45465800e1a7cdb",
  "confirmations": 9,
  "blocktime": 1557377749
}
</pre>


====getApplicationLog====
Get the application log for a given transaction.


'''Method Interface'''

<pre>
function getApplicationLog({
  txid: string,
  network?: string
}): Promise<{result: ApplicationLog}>
</pre>


'''Input arguments'''

<pre>
interface TransactionInputArgs {
  txid: string;
  network?: string;
}
</pre>


'''Success return value'''

<pre>
export interface ApplicationLog {
  txid: string;
  executions: ExecutionDetails[];
}

interface ExecutionDetails {
  trigger: string;
  contract: string; // Transaction execution Script Hash
  vmstate: string;
  gas_consumed: string;
  stack: Argument[];
  notifications: Notification[];
}

interface Notification {
  contract: string; // Contract Hash where the transaction execution notice is located
  state: {
    type: 'Array';
    value: Argument[];
  };
}

interface Argument {
  type: string;
  value: string;
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string;
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getApplicationLog({
  txid: '7e049fd7c253dabf38e4156df30c78b30d49f307196aa89b99a47d2330789bf2',
  network: 'TestNet'
})
.then((result: Object) => {
  console.log('Application log of transaction execution: ' + JSON.stringigy(result));
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
   case RPC_ERROR:
    console.log('There was an error when broadcasting this transaction to the network.');
    break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Broadcast the RPC request
* Return the RPC response results


Example
<pre>
{
  "txid": "0x7e049fd7c253dabf38e4156df30c78b30d49f307196aa89b99a47d2330789bf2",
  "executions": [
    {
      "trigger": "Application",
      "contract": "0x72985e7f2cea98b89af54d8607bc6400814c4b45",
      "vmstate": "HALT",
      "gas_consumed": "5.292",
      "stack": [],
      "notifications": [
        {
          "contract": "0x849d095d07950b9e56d0c895ec48ec5100cfdff1",
          "state": {
            "type": "Array",
            "value": [
              {
                "type": "ByteArray",
                "value": "7472616e73666572"
              },
              {
                "type": "ByteArray",
                "value": "296ac124021a71c449a9bad320c16429b08ad6ee"
              },
              {
                "type": "ByteArray",
                "value": "7869ef9732cdf6f6d54adaa5cae3b55a9396bceb"
              },
              {
                "type": "ByteArray",
                "value": "00e1f505"
              }
            ]
          }
        },
        {
          "contract": "0x849d095d07950b9e56d0c895ec48ec5100cfdff1",
          "state": {
            "type": "Array",
            "value": [
              {
                "type": "ByteArray",
                "value": "7472616e73666572"
              },
              {
                "type": "ByteArray",
                "value": "296ac124021a71c449a9bad320c16429b08ad6ee"
              },
              {
                "type": "ByteArray",
                "value": "b1fdddf658ce5ff9f83e66ede2f333ecfcc0463e"
              },
              {
                "type": "ByteArray",
                "value": "00e1f505"
              }
            ]
          }
        }
      ]
    }
  ]
}
</pre>


===Write Methods===
====send====
Invoke a transfer of a specified amount of a given asset from the connected account to another account.


'''Method Interface'''

<pre>
function send({
  fromAddress: string,
  toAddress: string,
  asset: string,
  amount: string,
  remark?: string,
  fee?: string,
  network?: string,
  broadcastOverride?: boolean,
}): Promise<SendOutput>
</pre>


'''Input arguments'''

<pre>
interface SendArgs {
  fromAddress: string; // Address of the connected account to send the assets from
  toAddress: string; // Address of the receiver of the assets to be sent
  asset: string; // Asset script hash to be sent
  amount: string; // The parsed amount of the asset to be sent
  remark?: string; // (Optional) Description of the transaction to be made
  fee?: string; // (Optional) The parsed amount of network fee (in GAS) to include with transaction
  network?: string; //  Network to submit this request to. If omitted, it will default to the network the wallet is currently set to.
  broadcastOverride?: boolean; // In the case that the dApp would like to be responsible for broadcasting the signed transaction rather than the wallet provider
}
</pre>


'''Success return value'''

<pre>
interface SendOutput {
  txid: string; // The transaction ID of the send invocation
  nodeUrl?: string; // The node which the transaction was broadcast to. Returned if the transaction is broadcast by a wallet provider
  signedTx?: string; // The serialized signed transaction. Only returned if the broadcastOverride input argument was set to True
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_REFUSED`|`SEND_ERROR`|`MALFORMED_INPUT`|`CANCELED`|`INSUFFICIENT_FUNDS`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
send({
  fromAddress: 'ATaWxfUAiBcQixNPq6TvKHEHPQum9bx79d',
  toAddress: 'ATaWxfUAiBcQixNPq6TvKHEHPQum9bx79d',
  asset: '602c79718b16e442de58778e148d0b1084e3b2dffd5de6b7b16cee7969282de7',
  amount: '0.0001',
  remark: 'Hash puppy clothing purchase. Invoice#abc123',
  fee: '0.0001'
})
.then(({txid, nodeUrl}: SendOutput) => {
  console.log('Send transaction success!');
  console.log('Transaction ID: ' + txid);
  console.log('RPC node URL: ' + nodeUrl);
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case SEND_ERROR:
      console.log('There was an error when broadcasting this transaction to the network.');
      break;
    case MALFORMED_INPUT:
      console.log('The receiver address provided is not valid.');
      break;
    case CANCELED:
      console.log('The user has canceled this transaction.');
      break;
    case INSUFFICIENT_FUNDS:
      console.log('The user has insufficient funds to execute this transaction.');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Validate the inputs
** From address matches connected account
** To address is valid
** Validate asset exists
** Amount is a valid value, and account has enough balance
* If the "broadcastOverride" input argument is set to True, return the serialized signed transaction to the dApp
* Else broadcast the RPC request
* Return the transaction Id and the url of the rpc node which the tx was broadcast to

Example
<pre>
{
  txid: 'ed54fb38dff371be6e3f96e4880405758c07fe6dd1295eb136fe15f311e9ff77',
  nodeUrl: 'http://seed7.ngd.network:10332',
}
</pre>


====invoke====
Execute a contract invocation.


'''Method Interface'''

<pre>
function invoke({
  scriptHash: string,
  operation: string,
  args: Argument[],
  attachedAssets?: AttachedAssets,
  fee?: string,
  assetIntentOverrides?: AssetIntentOverrides,
  triggerContractVerification?: boolean,
  network?: string,
  broadcastOverride?: boolean,
  txHashAttributes?: TxHashAttribute[],
}): Promise<InvokeOutput>
</pre>


'''Input arguments'''

<pre>
interface InvokeArgs {
  scriptHash: string; // script hash of the smart contract to invoke
  operation: string; // operation on the smart contract to call
  args: Argument[]; // any input arguments for the operation
  fee?: string; // (Optional) The parsed amount of network fee (in GAS) to include with transaction
  network?: string - Network to submit this request to. If omitted, it will default to the network the wallet is currently set to.
  attachedAssets?: AttachedAssets;
  broadcastOverride?: boolean; // In the case that the dApp would like to be responsible for broadcasting the signed transaction rather than the wallet provider

  assetIntentOverrides?: AssetIntentOverrides;
  // A hard override of all transaction utxo inputs and outputs.
  // IMPORTANT: If provided, fee and attachedAssets will be ignored.

  triggerContractVerification?: boolean; // Adds the instruction to invoke the contract verification trigger

  txHashAttributes?: TxHashAttribute[]; // Adds transaction attributes for the "Hash<x>" usage block
}

interface Argument {
  type: ArgumentDataType;
  value: any;
}

interface TxHashAttribute extends Argument {
  txAttrUsage: 'Hash1'|'Hash2'|'Hash3'|'Hash4'|'Hash5'|'Hash6'|'Hash7'|'Hash8'|'Hash9'|'Hash10'|'Hash11'|'Hash12'|'Hash13'|'Hash14'|'Hash15';
}

type ArgumentDataType = 'String'|'Boolean'|'Hash160'|'Hash256'|'Integer'|'ByteArray'|'Array'|'Address';

interface AttachedAssets {
  [asset: 'NEO'|'GAS']: string;
}
// KEY: Asset symbol (only NEO or GAS)
// VALUE: Parsed amount to attach

interface AssetIntentOverrides {
  inputs: UTXOAssetInput[];
  outputs: AssetOutput[];
}

interface UTXOAssetInput {
  txid: string;
  index: number;
}

interface AssetOutput {
  asset: string;
  address: number;
  value: string;
}

</pre>


'''Success return value'''

interface InvokeOutput {
  txid: string; // The transaction ID of the invocation
  nodeUrl?: string; // The node which the transaction was broadcast to. Returned if the transaction is broadcast by a wallet provider
  signedTx?: string; // The serialized signed transaction. Only returned if the broadcastOverride input argument was set to True
}


'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_REFUSED`|`SEND_ERROR`|`MALFORMED_INPUT`|`CANCELED`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
invoke({
  scriptHash: '505663a29d83663a838eee091249abd167e928f5',
  operation: 'storeData',
  arguments: [
    {
      type: 'string',
      value: 'hello'
    }
  ],
  attachedAssets: {
    NEO: '100',
    GAS: '0.0001',
  },
  fee: '0.001'
})
.then(({txid, nodeUrl}: InvokeOutput) => {
  console.log('Invoke transaction success!');
  console.log('Transaction ID: ' + txid);
  console.log('RPC node URL: ' + nodeUrl);
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case RPC_ERROR:
      console.log('There was an error when broadcasting this transaction to the network.');
      break;
    case CANCELED:
      console.log('The user has canceled this transaction.');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Validate and format the inputs
** Script hash is valid
** Format parameters
*** If `byteArray`, convert to appropriate hexstring based on assumed format
* Set script transaction attribute 0x20 according to the following conditions
** If triggerContractVerification is set to true, set 0x20 to scriptHash of the contract being invoked
** If there is no fee, attachedAssets, or 'assetIntentOverrides', set 0x20 to the users address
** If there are assetIntentOverrides but none of the inputs belong to the user address, set 0x20 to user address
* If the "broadcastOverride" input argument is set to True, return the serialized signed transaction to the dApp
* Else broadcast the RPC request
* Return the transaction Id and the url of the rpc node which the tx was broadcast to

Example
<pre>
{
  txid: 'ed54fb38dff371be6e3f96e4880405758c07fe6dd1295eb136fe15f311e9ff77',
  nodeUrl: 'http://seed7.ngd.network:10332',
}:
</pre>


====invokeMulti====
Execute a multiple contract invocations in a single transaction.


'''Method Interface'''

<pre>
function invokeMulti({
  invokeArgs: InvokeArguments[],
  fee?: string,
  assetIntentOverrides?: AssetIntentOverrides,
  network?: string,
  broadcastOverride?: boolean,
  txHashAttributes?: TxHashAttribute[],
}): Promise<InvokeOutput>
</pre>


'''Input arguments'''

<pre>
interface InvokeMultiArgs {
  invokeArgs: InvokeArguments[]; List of contract invoke inputs

  fee?: string; // (Optional) The parsed amount of network fee (in GAS) to include with transaction
  network?: string - Network to submit this request to. If omitted, it will default to the network the wallet is currently set to.
  broadcastOverride?: boolean; // In the case that the dApp would like to be responsible for broadcasting the signed transaction rather than the wallet provider

  assetIntentOverrides?: AssetIntentOverrides;
  // A hard override of all transaction utxo inputs and outputs.
  // IMPORTANT: If provided, fee and attachedAssets will be ignored.

  txHashAttributes?: TxHashAttribute[]; // Adds transaction attributes for the "Hash<x>" usage block
}

interface InvokeArguments {
  scriptHash: string; // script hash of the smart contract to invoke
  operation: string; // operation on the smart contract to call
  args: Argument[]; // any input arguments for the operation
  attachedAssets?: AttachedAssets;
  triggerContractVerification?: boolean; // Adds the instruction to invoke the contract verification trigger
}

interface Argument {
  type: ArgumentDataType;
  value: any;
}

interface TxHashAttribute extends Argument {
  txAttrUsage: 'Hash1'|'Hash2'|'Hash3'|'Hash4'|'Hash5'|'Hash6'|'Hash7'|'Hash8'|'Hash9'|'Hash10'|'Hash11'|'Hash12'|'Hash13'|'Hash14'|'Hash15';
}

type ArgumentDataType = 'String'|'Boolean'|'Hash160'|'Hash256'|'Integer'|'ByteArray'|'Array'|'Address';

interface AttachedAssets {
  [asset: 'NEO'|'GAS']: string;
}
// KEY: Asset symbol (only NEO or GAS)
// VALUE: Parsed amount to attach

interface AssetIntentOverrides {
  inputs: AssetInput[];
  outputs: AssetOutput[];
}

interface AssetInput {
  txid: string;
  index: number;
}

interface AssetOutput {
  asset: string;
  address: number;
  value: string;
}

</pre>


'''Success return value'''

interface InvokeMultiOutput {
  txid: string; // The transaction ID of the invocation
  nodeUrl?: string; // The node which the transaction was broadcast to. Returned if the transaction is broadcast by a wallet provider
  signedTx?: string; // The serialized signed transaction. Only returned if the broadcastOverride input argument was set to True
}


'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_REFUSED`|`SEND_ERROR`|`MALFORMED_INPUT`|`CANCELED`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
invokeMulti({
  invokeArgs: [
    {
      scriptHash: '505663a29d83663a838eee091249abd167e928f5',
      operation: 'storeData',
      arguments: [
        {
          type: 'string',
          value: 'hello'
        }
      ],
      attachedAssets: {
        NEO: '100',
        GAS: '0.0001',
      },
      triggerContractVerification: true,
    },
    {
      scriptHash: '505663a29d83663a838eee091249abd167e928f5',
      operation: 'purchaseTicket',
      arguments: [
        {
          type: 'number',
          value: '10'
        }
      ],
    }
  ],
  fee: '0.001',
  network: 'TestNet',
  broadcastOverride: false,
  txHashAttributes: [
    {
      type: 'Boolean',
      value: true,
      txAttrUsage: 'Hash1'
    }
  ]
})
.then(({txid, nodeUrl}: InvokeOutput) => {
  console.log('Invoke transaction success!');
  console.log('Transaction ID: ' + txid);
  console.log('RPC node URL: ' + nodeUrl);
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case RPC_ERROR:
      console.log('There was an error when broadcasting this transaction to the network.');
      break;
    case CANCELED:
      console.log('The user has canceled this transaction.');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Validate and format the inputs
** Script hashes is valid
** Format parameters
*** If `byteArray`, convert to appropriate hexstring based on assumed format
* Batch invoke inputs into script and handle assets to each invoke as outputs
* Set script transaction attribute 0x20 according to the following conditions
** If triggerContractVerification is set to true, set 0x20 to scriptHash of the contract being invoked
** If there is no fee, attachedAssets, or 'assetIntentOverrides', set 0x20 to the users address
** If there are assetIntentOverrides but none of the inputs belong to the user address, set 0x20 to user address
* If the "broadcastOverride" input argument is set to True, return the serialized signed transaction to the dApp
* Else broadcast the RPC request
* Return the transaction Id and the url of the rpc node which the tx was broadcast to

Example
<pre>
{
  txid: 'ed54fb38dff371be6e3f96e4880405758c07fe6dd1295eb136fe15f311e9ff77',
  nodeUrl: 'http://seed7.ngd.network:10332',
}:
</pre>


====signMessage====
Signs a provided messaged with an account selected by user. A randomized salt prefix is added to the input string before it is signed, and it is encased in a non-executable transaction before signed. This ensures allow compatibility with Ledger devices.


'''Method Interface'''

<pre>
function signMessage({message: string}): Promise<SignedMessage>
</pre>


'''Input arguments'''

<pre>
interface SignMessageArgs {
  message: string; // Arbitrary message to sign
}
</pre>


'''Success return value'''

<pre>
interface SignedMessage {
  publicKey: string; // Public key of account that signed message
  message: string; // Original message signed
  salt: string; // Salt added to original message as prefix, before signing
  data: string; // Signed message
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string;
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
signMessage({
  message: 'Hello World!',
})
.then((signedMessage: SignedMessage) => {
  const {
    publicKey,
    message,
    salt,
    data,
  } = signedMessage;

  console.log('Public key used to sign:', publicKey);
  console.log('Original message:', message);
  console.log('Salt added to message:', salt);
  console.log('Signed data:', data);
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case UNKNOWN_ERROR:
      console.log(description);
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Present the message to the user for signing
* Create a randomized salt value to be prefixed to the message before signing
* Create the hexstring to be signed. '010001f0' + {length of salt+message in hex} + salt + message + '0000'
* Sign the hexstring value once the user confirms
* Return to dApp

For more details, please see:
[https://docs.switcheo.network/#signing-messages-for-neo]

Example
<pre>
{
  publicKey: '0241392007396d6ef96159f047967c5a61f1af0871ecf9dc82afbedb68afbb949a',
  data: '0147fb89d0999e9d8a90edacfa26152fe695ec8b3770dcad522048297ab903822e12472364e254ff2e088fc3ebb641cc24722c563ff679bb1d1623d08bd5863d0d',
  salt: '058b9e03e7154e4db1e489c99256b7fa',
  message: 'Hello World!',
}
</pre>

====deploy====
Will deploy a compiled smart contract to the blockchain with the provided input parameters. The GAS cost for deploying the contract will be calculated by the provider and displayed to the user upon tx acceptance or rejection.


'''Method Interface'''

<pre>
function deploy({
  name: string,
  version: string,
  author: string,
  email: string,
  description: string,
  needsStorage?: boolean,
  dynamicInvoke?: boolean,
  isPayable?: boolean,
  parameterList: string,
  returnType: string,
  code: string,
  network?: string,
  broadcastOverride?: boolean,
}): Promise<DeployOutput>
</pre>


'''Input arguments'''

<pre>
interface DeployArgs {
  name: string;
  version: string;
  author: string;
  email: string;
  description: string;
  needsStorage?: boolean;
  dynamicInvoke?: boolean;
  isPayable?: boolean;
  parameterList: string;
  returnType: string;
  code: string;
  network?: string - Network to submit this request to. If omitted, will default to network the wallet is currently set to.
  broadcastOverride?: boolean; // In the case that the dApp would like to be responsible for broadcasting the signed transaction rather than the wallet provider
}
</pre>


'''Success return value'''

<pre>
interface DeployOutput {
  txid: string;
  nodeUrl?: string; // The node which the transaction was broadcast to. Returned if transaction is broadcast by wallet provider
  signedTx?: string; // The serialized signed transaction. Only returned if the broadcastOverride input argument was set to True
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string;
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
deploy({
  name: 'Hello world!',
  version: 'v0.0.1',
  author: 'John Smith',
  email: 'info@o3.network',
  description: 'My first contract.',
  needsStorage: true,
  dynamicInvoke: false,
  isPayable: false,
  parameterList: '0710',
  returnType: '05',
  code: '53c56b0d57616b652075702c204e454f21680f4e656f2e52756e74696d652e4c6f6761006c7566',
})
.then(({txid, nodeUrl}: InvokeOutput) => {
  console.log('Deploy transaction success!');
  console.log('Transaction ID: ' + txid);
  console.log('RPC node URL: ' + nodeUrl);
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case UNKNOWN_ERROR:
      console.log(description);
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Run a testinvoke on the deploy transaction to get the gas cost in order to deploy the contract
* Display the deploy input parameters to the user along with the associated deployment fee
* Sign transaction upon receiving confirmation from user
* If the "broadcastOverride" input argument is set to True, return the serialized signed transaction to the dApp
* Else broadcast the RPC request
* Return the transaction Id and the url of the rpc node which the tx was broadcast to

Example
<pre>
{
  txid: 'ed54fb38dff371be6e3f96e4880405758c07fe6dd1295eb136fe15f311e9ff77',
  nodeUrl: 'http://seed7.ngd.network:10332',
}
</pre>


===Events===

dApps can listen for events emitted by the wallet provider using the `addEventListener` method.

====addEventListener====

'''Method Interface'''

<pre>
function addEventListener(event: Event, callback: Function): Void
</pre>

'''Input arguments'''

<pre>
enum Event {
  READY = 'READY',
  ACCOUNT_CHANGED = 'ACCOUNT_CHANGED',
  NETWORK_CHANGED = 'NETWORK_CHANGED',
  CONNECTED = 'CONNECTED',
  DISCONNECTED = 'DISCONNECTED',
  BLOCK_HEIGHT_CHANGED = 'BLOCK_HEIGHT_CHANGED',
  TRANSACTION_CONFIRMED = 'TRANSACTION_CONFIRMED'
}
</pre>

=====READY=====

On a READY event, the callback will fire with a single argument with information about the wallet provider. At any time a READY event listener is added, it will immediately be called if the provider is already in a ready state. This provides a single flow for dApp developers since this listener should start any and all interactions with the dAPI protocol.
<pre>
interface Provider {
  name: string;
  website: string;
  version: string;
  compatibility: string[];
}
</pre>

=====ACCOUNT_CHANGED=====

On a ACCOUNT_CHANGED event, the callback will fire with a single argument of the new account. This occurs when an account is already connected to the dApp, and the user has changed the connected account from the dAPI provider side.
<pre>
interface Account {
  address: string; // Address of the connected account
  label?: string; // A label the users has set to identify their wallet
}
</pre>

=====CONNECTED=====
On a CONNECTED event, the user has approved the connection of the dApp with one of their accounts. This will fire the first time any of one of the following methods are called from the dApp: getAccount, invoke, send.

<pre>
interface Account {
  address: string; // Address of the connected account
  label?: string; // A label the users has set to identify their wallet
}
</pre>


=====DISCONNECTED=====

On a DISCONNECTED event, the account connected to the dApp via the dAPI provider has been disconnected (logged out).


=====NETWORK_CHANGED=====

On a NETWORK_CHANGED event, the callback will fire with a single argument of the new network details. This occurs when the user has changed the network on their provider wallet.

<pre>
interface Networks {
  networks: string[]; // Array of network names the wallet provider has available for the dapp developer to connect to.
  defaultNetwork: string; // Network the wallet is currently set to.
}
</pre>

Example:
<pre>
{
  networks: ["MainNet"],
  defaultNetwork: "MainNet",
}
</pre>

=====BLOCK_HEIGHT_CHANGED=====

On a BLOCK_HEIGHT_CHANGED event, the block has advanced to the next.

<pre>
interface BlockHeightChanged {
  network: string; // Network of the block which changed
  blockHeight: integer; // Height of the new block
  blockTime: integer; // Timestamp of the new block
  blockHash: string; // Hash of the new block
  tx: string[]; // List of transaction ids executed in the new block
}
</pre>

Example:
<pre>
{
  "blockHash": "0x5d19f31f5488ebcb0ab4aabfbead2118744b59e6c91b42696cee73f026e6dde8",
  "blockHeight": 2619937,
  "blockTime": 1557382020,
  "network": "TestNet",
  "tx": [
    "8f321fe22c4993d863e369fe30798c50a24400cec714373f63fcd88cb5402976"
  ]
}
</pre>

=====TRANSACTION_CONFIRMED=====

On a TRANSACTION_CONFIRMED event, a previously broadcast transaction via the dAPI has been confirmed by the blockchain.

<pre>
interface BlockHeightChanged {
  txid: string; // Transaction id which was confirmed on chain
  blockHeight: integer; // Height of the new block
  blockTime: integer; // Timestamp of the new block
}
</pre>

Example:
<pre>
{
  "txid": "8f321fe22c4993d863e369fe30798c50a24400cec714373f63fcd88cb5402976",
  "blockHeight": 2619937,
  "blockTime": 1557382020
}
</pre>


====removeEventListener====

Removes any callback listeners previously set for a given event.

'''Method Interface'''

<pre>
function removeEventListener(event: Event): Void
</pre>

'''Input arguments'''

<pre>
enum Event {
  READY = 'READY',
  ACCOUNT_CHANGED = 'ACCOUNT_CHANGED',
  NETWORK_CHANGED = 'NETWORK_CHANGED',
  CONNECTED = 'CONNECTED',
  DISCONNECTED = 'DISCONNECTED',
  BLOCK_HEIGHT_CHANGED = 'BLOCK_HEIGHT_CHANGED',
  TRANSACTION_CONFIRMED = 'TRANSACTION_CONFIRMED'
}
</pre>

===Error handling===

All methods return a promise which will resolve or reject. In the case of a rejection, the return argument will be an object formatted with standard fields for the type of error, a brief description, and any raw error data.

<pre>
interface Error {
  type: string;
  description?: string;
  data?: any;
}
</pre>

Common error definitions
<pre>
NO_PROVIDER -> Thrown when there is no interface capable of interacting with NEO blockchain
CONNECTION_DENIED -> Thrown when API provider refuses to execute a transaction (e.g. trying to execute a transaction on an unavailable network)
RPC_ERROR -> Thrown when a command relying on RPC connection to a network node fails
MALFORMED_INPUT -> Thrown when an input such as the address is not a valid NEO address
CANCELED -> Thrown when a user cancels or refuses the dApp's request
INSUFFICIENT_FUNDS -> Thrown when the action does not have a sufficient balance
</pre>


==Rational==

This protocol will allow dApp developers to create applications that interact with the NEO blockchain without having to be concerned about managing a full wallet within their application or the details related to handing transaction creation or broadcasting. This will also allow dApps to allow users to transact in a secure fashion that does not require sharing of their private key.

==Wallet Provider Implementations==

===O3===
[https://o3.network O3 Wallet]

[https://docs.o3.network/neoDapi/ dAPI Documentation]

[https://github.com/O3Labs/o3-dapi/tree/master/packages/neo Client JS Package (NPM/CDN)]

===NeoLogin===
[https://neologin.io/ NeoLogin]

[https://neologin.io/api/ dAPI Documentation]

===NEOLine===
[https://neoline.cn/ NEOLine]

[https://neoline.cn/dapi/ dAPI Documentation]

==dApp Client Integrations==

[https://switcheo.exchange/markets/NEX_NEO?ref=o3.network Switcheo]

[https://store.neoeconomy.io/?ref=o3 NEO Economy Store]

[http://dgamemaker.io/presale/ Decentralized Game Maker]

[https://neo.alchemint.io/o3 Alchemint]

[https://www.ftwlotto.com/?provider=o3 FTW]

[https://neo.blocklords.io/?referalLink=AYWoyNjQwpLr1Ni7EC4HR5mQfrrRtqyPi4-1455 BLOCKLORDS]

[https://blockchaincuties.com/neopresalestore?utm_source=o3wallet&utm_medium=referral BlockChain Cuties]

[https://swap.o3.app/ O3 Swap]

[https://utxo-manager.o3.app/ UTXO Manager]

[https://buy.o3.network/ O3 Fiat Gateway]

[https://neodapitestbed.o3.app/ NEO dAPI Testbed]
